/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package de.lomboker.lib;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.visitor.GenericVisitor;
import com.github.javaparser.ast.visitor.VoidVisitor;
import com.github.javaparser.printer.lexicalpreservation.LexicalPreservingPrinter;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;


public class GetterReducer {
    
    public static String reduceGetters(String code) {
        CompilationUnit cu = StaticJavaParser.parse(code);
        LexicalPreservingPrinter.setup(cu);

        Map<String, FieldDeclaration> members = new HashMap<>();
        for (FieldDeclaration fd: cu.findAll(FieldDeclaration.class)) {
            members.put(fd.getVariable(0).getName().asString(), fd);
        }

        //all methods that return a field
        Map<String, MethodDeclaration> methods = cu
                .findAll(MethodDeclaration.class)
                .stream()
                .filter(GetterReducer::isGetter)
                .collect(Collectors.toMap(GetterReducer::getReturned, Function.identity()));

        //intersect keys
        Set<String> intersection = new HashSet<>(members.keySet()); // use the copy constructor
        intersection.retainAll(methods.keySet());

        //add annotation and remove method
        for (String name: intersection) {
            members.get(name).addMarkerAnnotation("Getter");
            methods.get(name).remove();
        }

        return LexicalPreservingPrinter.print(cu);
    }

    /**
     * Determines whether a method is a Getter i.e. whether it
     * <ul>
     *   <li> takes no parameters </li>
     *   <li> has exactly one command that returns an expression without spaces</li>
     * </ul>
     *
     * @param md MethodDeclaration to inspect
     * @return true if method is a getter, false otherwise
     */
    public static boolean isGetter(MethodDeclaration md) {
        boolean noParameters = md.getParameters().isEmpty();

        Optional<Expression> returnStm = getReturnStatement(md);

        return noParameters && returnStm.isPresent();
    }

    private static Optional<Expression> getReturnStatement(MethodDeclaration md) {
        if (md.getBody().isEmpty()) {
            return Optional.empty();
        }
        NodeList<Statement> statements = md.getBody().get().getStatements();
        if (statements.size() != 1)
            return Optional.empty();

        Statement onlyStmt = statements.getFirst().get();

        if (!onlyStmt.isReturnStmt()) {
            return Optional.empty();
        }

        Optional<Expression> oExpression = onlyStmt.asReturnStmt().getExpression();

        if (oExpression.isEmpty()
            || oExpression.get().toString().contains(" "))
            return Optional.empty();

        return oExpression;
    }

    private static boolean isTrivialGetter(MethodDeclaration md, Set<String> fields) {
        if (!isGetter(md)) {
            return false;
        }

        //Verify that the name is what lombok would create
        String methodName = md.getNameAsString();
        String type = md.getTypeAsString();
        if (fields.stream().noneMatch(f -> signatureMatch(methodName, type, f)))
            return false;

        return true;
    }

    private static boolean signatureMatch(String methodName, String type, String variable) {
        if ("void".equals(type))
            return false;

        if (!methodName.startsWith("boolean".equals(type) ? "has" : "get")) {
            return false;
        }
        String tail = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(3);
        return  tail.equals(variable);

    }

    /**
     * returns the name of the returned expression / a stng representation of the returned statement
     * assumptions:
     *  - there is a return statement
     *
     *  */
    private static String getReturned(MethodDeclaration md) {
        return md.getBody().get().getStatements().stream()
                .filter(Statement::isReturnStmt)
                .reduce((first, second) -> second).get() //last element
                .asReturnStmt().getExpression().get().toString();
    }

}
